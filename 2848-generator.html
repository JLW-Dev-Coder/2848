<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Form 2848 Generator (Stamp)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 28px; line-height: 1.45; }
    h1 { margin: 0 0 6px; }
    .meta { color: #555; font-size: 12px; margin: 0 0 18px; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; margin: 0 0 14px; }
    .pill { background: #f3f4f6; border-radius: 999px; font-size: 12px; max-width: 100%; overflow: hidden; padding: 6px 10px; text-overflow: ellipsis; white-space: nowrap; }
    .btn { cursor: pointer; padding: 10px 14px; }
    #status { margin-top: 14px; font-size: 14px; }
  </style>
</head>
<body>
  <h2 style="color:red">RUNNING BUILD XYZ</h2>

  <h1>Form 2848 Generator</h1>
  <p class="meta" id="buildMeta">Stamped onto a flattened IRS PDF (no form fields required).</p>

  <div class="row" id="summary"></div>

  <div class="row">
    <button class="btn" id="generate" type="button">Generate PDF</button>
  </div>

  <div id="status">Ready.</div>

  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script>
    (function () {
      const { PDFDocument, rgb, StandardFonts } = PDFLib;

      const BUILD_ID = "2848-align-2026-01-22-h";

      const qs = new URLSearchParams(window.location.search);

      function clean(v) {
        const s = String(v == null ? "" : v).trim();
        if (!s) return "";
        if (s.startsWith("{{") && s.endsWith("}}")) return "";
        return s;
      }

      function get(k) { return clean(qs.get(k)); }
      function getBool(k) { return ["1", "true", "yes", "on"].includes((qs.get(k) || "").toLowerCase()); }

      const DEBUG = {
        grid: get("grid") === "1",
        gridStep: Number(get("gridStep") || 50),
        labels: get("labels") === "1",
        ox: Number(get("ox") || 0),
        oy: Number(get("oy") || 0),
        stamp: get("stamp") === "1"
      };

      const V = get("v") || String(Date.now());

      document.getElementById("buildMeta").textContent =
        `Stamped onto a flattened IRS PDF (no form fields required). BUILD=${BUILD_ID}`;

      const data = {
        TaxpayerSSNITIN: get("TaxpayerSSNITIN"),

        clientAddressLine1: get("clientAddressLine1"),
        clientAddressLine2: get("clientAddressLine2"),
        clientAddressRegion: get("clientAddressRegion"),
        clientAddressTown: get("clientAddressTown"),
        clientAddressZip: get("clientAddressZip"),
        clientFirstName: get("clientFirstName"),
        clientLastName: get("clientLastName"),

        line3DescriptionOfMatter: get("line3DescriptionOfMatter") ||
          "Income, Employment, Payroll, Excise, Estate, Gift, Civil Penalty, Sec. 4980H Shared Responsibility Payment",

        line3TaxFormNumber: get("line3TaxFormNumber") || "940, 941, 720, 1040, 1120, 1120S",

        line5aAccessRecords: getBool("line5aAccessRecords") || true,
        line5aAuthorizeDisclosure: getBool("line5aAuthorizeDisclosure") || false,
        line5aSignReturn: getBool("line5aSignReturn") || false,
        line5aSubstituteOrAddRep: getBool("line5aSubstituteOrAddRep") || true,

        repAddr1: get("2848Rep1AddressLine1") || get("2848_Rep_1_Address_Line_1"),
        repAddr2: get("2848Rep1AddressLine2") || get("2848_Rep_1_Address_Line_2"),
        repCAF:   get("2848Rep1CAF")          || get("2848_Rep_1_CAF"),
        repCity:  get("2848Rep1AddressCity")  || get("2848_Rep_1_Address_City"),
        repFax:   get("2848Rep1Fax")          || get("2848_Rep_1_Fax"),
        repFirst: get("2848Rep1FirstName")    || get("2848_Rep_1_First_Name"),
        repLast:  get("2848Rep1LastName")     || get("2848_Rep_1_Last_Name"),
        repPTIN:  get("2848Rep1PTIN")         || get("2848_Rep_1_PTIN"),
        repState: get("2848Rep1AddressState") || get("2848_Rep_1_Address_State"),
        repTel:   get("2848Rep1Telephone")    || get("2848_Rep_1_Telephone"),
        repZip:   get("2848Rep1AddressZip")   || get("2848_Rep_1_Address_Zip"),

        yearFrom: get("myOrganizationIRSCurrentTaxYear10ComplianceYears"),
        yearTo: get("myOrganizationIRSCurrentTaxYear")
      };

      const IRS_TEXT_SIZE = 8.5;

      const POS = {
        // Row 1 anchors
        acts_desc_1: { x: 40,  y: 240, size: IRS_TEXT_SIZE },
        acts_form_1: { x: 330, y: 240, size: IRS_TEXT_SIZE },
        acts_year_1: { x: 474, y: 240, size: IRS_TEXT_SIZE },

        // Row 2 anchors (we will KEEP years in column 3 on row 1 by nesting line 2)
        acts_desc_2: { x: 40,  y: 205, size: IRS_TEXT_SIZE },
        acts_form_2: { x: 330, y: 205, size: IRS_TEXT_SIZE },
        acts_year_2: { x: 474, y: 205, size: IRS_TEXT_SIZE },

        // Row 3 anchors (unused, left blank)
        acts_desc_3: { x: 40,  y: 180, size: IRS_TEXT_SIZE },
        acts_form_3: { x: 330, y: 180, size: IRS_TEXT_SIZE },
        acts_year_3: { x: 474, y: 180, size: IRS_TEXT_SIZE },

        line5aAccessISP_Check:           { x: 230, y: 137 },
        line5aAuthorizeDisclosure_Check: { x: 55,  y: 130 },
        line5aSignReturn_Check:          { x: 560, y: 130 },
        line5aSubAddRep_Check:           { x: 230, y: 126 },

        repBlock: { x: 40, y: 565, lineGap: 11, size: IRS_TEXT_SIZE },

        repCAF:  { x: 395, y: 578, size: IRS_TEXT_SIZE },
        repPTIN: { x: 396, y: 566, size: IRS_TEXT_SIZE },
        repTel:  { x: 413, y: 553, size: IRS_TEXT_SIZE },
        repFax:  { x: 405, y: 541, size: IRS_TEXT_SIZE },

        taxpayerNameAddressBlock: { x: 40, y: 640, lineGap: 9, size: IRS_TEXT_SIZE },
        taxpayerTIN: { x: 348, y: 640, size: IRS_TEXT_SIZE }
      };

      const status = document.getElementById("status");
      const summary = document.getElementById("summary");

      const pill = (label, value) => {
        const d = document.createElement("div");
        d.className = "pill";
        d.textContent = value ? `${label}: ${value}` : `${label}: (blank)`;
        summary.appendChild(d);
      };

      function ax(x) { return x + DEBUG.ox; }
      function ay(y) { return y + DEBUG.oy; }

      function drawMultiline(page, text, x, y, size, lineGap, font) {
        const lines = (text || "").split("\n").map(s => s.trim()).filter(Boolean);
        let cy = y;
        for (const line of lines) {
          page.drawText(line, { x, y: cy, size, font, color: rgb(0, 0, 0) });
          cy -= lineGap;
        }
      }

      function drawCheck(page, x, y, font) {
        page.drawText("X", { x: x + 1, y: y - 3, size: 8, font, color: rgb(0, 0, 0) });
      }

      function drawCrosshair(page, x, y) {
        const len = 8;
        page.drawLine({ start: { x: x - len, y }, end: { x: x + len, y }, thickness: 0.75, color: rgb(1, 0, 0) });
        page.drawLine({ start: { x, y: y - len }, end: { x, y: y + len }, thickness: 0.75, color: rgb(1, 0, 0) });
      }

      function drawGrid(page, font, width, height, step) {
        const thin = 0.4;
        const thick = 0.9;

        for (let x = 0; x <= width; x += step) {
          const isMajor = (x % (step * 2) === 0);
          page.drawLine({ start: { x, y: 0 }, end: { x, y: height }, thickness: isMajor ? thick : thin, color: rgb(0.75, 0.75, 0.75) });
          page.drawText(String(x), { x: Math.min(x + 2, width - 18), y: height - 12, size: 7, font, color: rgb(0.35, 0.35, 0.35) });
        }

        for (let y = 0; y <= height; y += step) {
          const isMajor = (y % (step * 2) === 0);
          page.drawLine({ start: { x: 0, y }, end: { x: width, y }, thickness: isMajor ? thick : thin, color: rgb(0.75, 0.75, 0.75) });
          page.drawText(String(y), { x: 2, y: Math.min(y + 2, height - 10), size: 7, font, color: rgb(0.35, 0.35, 0.35) });
        }

        page.drawText(`GRID step=${step} ox=${DEBUG.ox} oy=${DEBUG.oy} BUILD=${BUILD_ID}`, {
          x: 12, y: height - 26, size: 9, font, color: rgb(0.2, 0.2, 0.2)
        });
      }

      function drawAnchorLabels(page, font) {
        const anchors = [
          ["acts_desc_1", POS.acts_desc_1.x, POS.acts_desc_1.y],
          ["acts_form_1", POS.acts_form_1.x, POS.acts_form_1.y],
          ["acts_year_1", POS.acts_year_1.x, POS.acts_year_1.y],
          ["acts_desc_2", POS.acts_desc_2.x, POS.acts_desc_2.y],
          ["acts_form_2", POS.acts_form_2.x, POS.acts_form_2.y],
          ["acts_year_2", POS.acts_year_2.x, POS.acts_year_2.y],
          ["repBlock", POS.repBlock.x, POS.repBlock.y],
          ["taxpayerNameAddressBlock", POS.taxpayerNameAddressBlock.x, POS.taxpayerNameAddressBlock.y],
          ["taxpayerTIN", POS.taxpayerTIN.x, POS.taxpayerTIN.y]
        ];

        anchors.forEach(([name, x, y]) => {
          const px = ax(x);
          const py = ay(y);
          drawCrosshair(page, px, py);
          page.drawText(`${name} (${x},${y})`, { x: px + 10, y: py + 2, size: 7, font, color: rgb(1, 0, 0) });
        });
      }

      function formatPeriod(yearFrom, yearTo) {
        const a = String(yearFrom || "").trim();
        const b = String(yearTo || "").trim();
        if (a && b) return `${a} through ${b}`;
        return a || b || "";
      }

      function formatTin(v) {
        const raw = String(v || "").trim();
        if (!raw) return "";
        const digits = raw.replace(/\D/g, "");
        if (digits.length === 9) return `${digits.slice(0,3)}-${digits.slice(3,5)}-${digits.slice(5)}`;
        return raw;
      }

      // Split helpers (explicit, deterministic)
      function splitMatter(s) {
        const text = String(s || "").trim();
        if (!text) return ["", ""];
        const targetBreak = "Estate";
        const idx = text.indexOf(targetBreak);
        if (idx > 0) {
          const line1 = text.slice(0, idx).trim().replace(/,\s*$/, "") + ",";
          const line2 = text.slice(idx).trim();
          return [line1, line2];
        }
        // fallback: break at nearest comma around the middle
        const mid = Math.floor(text.length / 2);
        const left = text.lastIndexOf(",", mid);
        const right = text.indexOf(",", mid);
        const cut = (right !== -1 && (mid - left) > (right - mid)) ? right : left;
        if (cut > 0) return [text.slice(0, cut + 1).trim(), text.slice(cut + 1).trim()];
        return [text, ""];
      }

      function splitForms(s) {
        const text = String(s || "").trim();
        if (!text) return ["", ""];
        // exact split you requested
        const line1 = "940, 941, 720";
        const line2 = "1040, 1120, 1120S";
        // if custom input differs, try to split after third comma
        if (text.replace(/\s+/g, " ") === `${line1}, ${line2}`) return [line1, line2];
        const parts = text.split(",").map(p => p.trim()).filter(Boolean);
        if (parts.length <= 3) return [parts.join(", "), ""];
        return [parts.slice(0, 3).join(", "), parts.slice(3).join(", ")];
      }

      function splitYears(s) {
        const text = String(s || "").trim();
        if (!text) return ["", ""];
        // Split "YYYY through YYYY" into two lines
        const token = "through";
        const i = text.indexOf(token);
        if (i !== -1) {
          const a = text.slice(0, i).trim();
          const b = text.slice(i + token.length).trim();
          return [a, `through ${b}`.trim()];
        }
        // If only one year, keep single line
        return [text, ""];
      }

      const taxpayerName = [data.clientFirstName, data.clientLastName].filter(Boolean).join(" ").trim();
      const repName = [data.repFirst, data.repLast].filter(Boolean).join(" ").trim();

      const repAddr12 = [data.repAddr1, data.repAddr2].filter(Boolean).join(" ").trim();
      const repCityStateZip = [data.repCity, data.repState].filter(Boolean).join(", ") + (data.repZip ? " " + data.repZip : "");
      const repBlockText = [repName, repAddr12, repCityStateZip].map(s => (s || "").trim()).filter(Boolean).join("\n");

      const taxpayerAddr12 = [data.clientAddressLine1, data.clientAddressLine2].filter(Boolean).join(" ").trim();
      const taxpayerCityStateZip = [data.clientAddressTown, data.clientAddressRegion].filter(Boolean).join(", ") + (data.clientAddressZip ? " " + data.clientAddressZip : "");
      const taxpayerNameAddress = [taxpayerName, taxpayerAddr12, taxpayerCityStateZip].map(s => (s || "").trim()).filter(Boolean).join("\n");

      const periodText = formatPeriod(data.yearFrom, data.yearTo);

      pill("Build", BUILD_ID);
      pill("Period", periodText);
      pill("Representative", repName);
      pill("Taxpayer", taxpayerName);

      async function generate() {
        status.textContent = "Generating PDFâ€¦";

        const pdfUrl = `./f2848.pdf?v=${encodeURIComponent(V)}`;
        const res = await fetch(pdfUrl, { cache: "no-store" });
        if (!res.ok) throw new Error(`PDF fetch failed: ${res.status} ${res.statusText}`);
        const pdfBytes = await res.arrayBuffer();

        const pdfDoc = await PDFDocument.load(pdfBytes);
        const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
        const page1 = pdfDoc.getPages()[0];

        const { width, height } = page1.getSize();
        page1.setCropBox(0, 0, width, height);

        if (DEBUG.grid) drawGrid(page1, font, width, height, DEBUG.gridStep);
        if (DEBUG.labels) drawAnchorLabels(page1, font);

        if (DEBUG.stamp) {
          page1.drawText(`BUILD=${BUILD_ID} ox=${DEBUG.ox} oy=${DEBUG.oy}`, { x: 12, y: 40, size: 10, font, color: rgb(1, 0, 0) });
        }

        drawMultiline(
          page1,
          taxpayerNameAddress,
          ax(POS.taxpayerNameAddressBlock.x),
          ay(POS.taxpayerNameAddressBlock.y),
          POS.taxpayerNameAddressBlock.size,
          POS.taxpayerNameAddressBlock.lineGap,
          font
        );

        page1.drawText(formatTin(data.TaxpayerSSNITIN), {
          x: ax(POS.taxpayerTIN.x),
          y: ay(POS.taxpayerTIN.y),
          size: POS.taxpayerTIN.size,
          font,
          color: rgb(0, 0, 0)
        });

        drawMultiline(
          page1,
          repBlockText,
          ax(POS.repBlock.x),
          ay(POS.repBlock.y),
          POS.repBlock.size,
          POS.repBlock.lineGap,
          font
        );

        page1.drawText((data.repCAF || "").trim(),  { x: ax(POS.repCAF.x),  y: ay(POS.repCAF.y),  size: POS.repCAF.size,  font, color: rgb(0, 0, 0) });
        page1.drawText((data.repPTIN || "").trim(), { x: ax(POS.repPTIN.x), y: ay(POS.repPTIN.y), size: POS.repPTIN.size, font, color: rgb(0, 0, 0) });
        page1.drawText((data.repTel || "").trim(),  { x: ax(POS.repTel.x),  y: ay(POS.repTel.y),  size: POS.repTel.size,  font, color: rgb(0, 0, 0) });
        page1.drawText((data.repFax || "").trim(),  { x: ax(POS.repFax.x),  y: ay(POS.repFax.y),  size: POS.repFax.size,  font, color: rgb(0, 0, 0) });

        // ===== ROW 1 ONLY, WITH NESTED LINE 2 INSIDE EACH CELL =====
        const lineGap = 9;

        // Cell 1 (Description of matter): two lines at row1 y, then y-lineGap (still within cell 1)
        const matterLines = splitMatter(data.line3DescriptionOfMatter);
        if (matterLines[0]) page1.drawText(matterLines[0], { x: ax(POS.acts_desc_1.x), y: ay(POS.acts_desc_1.y), size: POS.acts_desc_1.size, font, color: rgb(0,0,0) });
        if (matterLines[1]) page1.drawText(matterLines[1], { x: ax(POS.acts_desc_1.x), y: ay(POS.acts_desc_1.y) - lineGap, size: POS.acts_desc_1.size, font, color: rgb(0,0,0) });

        // Cell 2 (Tax form number): two lines at row1 y, then y-lineGap
        const formLines = splitForms(data.line3TaxFormNumber);
        if (formLines[0]) page1.drawText(formLines[0], { x: ax(POS.acts_form_1.x), y: ay(POS.acts_form_1.y), size: POS.acts_form_1.size, font, color: rgb(0,0,0) });
        if (formLines[1]) page1.drawText(formLines[1], { x: ax(POS.acts_form_1.x), y: ay(POS.acts_form_1.y) - lineGap, size: POS.acts_form_1.size, font, color: rgb(0,0,0) });

        // Cell 3 (Years/period): two lines at row1 y, then y-lineGap
        const yearsLines = splitYears(periodText);
        if (yearsLines[0]) page1.drawText(yearsLines[0], { x: ax(POS.acts_year_1.x), y: ay(POS.acts_year_1.y), size: POS.acts_year_1.size, font, color: rgb(0,0,0) });
        if (yearsLines[1]) page1.drawText(yearsLines[1], { x: ax(POS.acts_year_1.x), y: ay(POS.acts_year_1.y) - lineGap, size: POS.acts_year_1.size, font, color: rgb(0,0,0) });

        // Leave rows 2/3 blank intentionally.

        if (data.line5aAuthorizeDisclosure) drawCheck(page1, ax(POS.line5aAuthorizeDisclosure_Check.x), ay(POS.line5aAuthorizeDisclosure_Check.y), font);
        if (data.line5aAccessRecords)      drawCheck(page1, ax(POS.line5aAccessISP_Check.x),          ay(POS.line5aAccessISP_Check.y),          font);
        if (data.line5aSubstituteOrAddRep) drawCheck(page1, ax(POS.line5aSubAddRep_Check.x),          ay(POS.line5aSubAddRep_Check.y),          font);
        if (data.line5aSignReturn)         drawCheck(page1, ax(POS.line5aSignReturn_Check.x),         ay(POS.line5aSignReturn_Check.y),         font);

        const out = await pdfDoc.save();
        const blob = new Blob([out], { type: "application/pdf" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "Form-2848-filled.pdf";
        document.body.appendChild(a);
        a.click();
        a.remove();

        URL.revokeObjectURL(url);
        status.textContent = "PDF generated.";
      }

      document.getElementById("generate").addEventListener("click", () => {
        generate().catch((e) => {
          console.error(e);
          status.textContent = `Error: ${e && e.message ? e.message : String(e)}`;
        });
      });
    })();
  </script>
</body>
</html>
